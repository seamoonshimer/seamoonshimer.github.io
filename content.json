{"pages":[{"title":"个人简历","text":"殷继亮 15068375219 · 15068375219@163.com · 中共党员 求职意向 : C++开发工程师 教育经历 硕士(2018.9~2020.6) : 杭州电子科技大学, 计算机科学与技术, GPA : 3.53/4.0 (专业前 5%), 本科(2014.9~2018.6) : 天津工业大学, 应用物理, GPA : 3.70/4.0 (专业前 5%), 专业技能 ★★★ (C++) 掌握 C++ 语言基础, 包括面向对象, STL, 基础数据结构和算法等; ★★★ (MySQL) 掌握 MySQL 操作基础, 包括基础语法, 事务, 三大范式, JDBC, SQL注入, 数据库连接池等; ★★★ (Nginx) ★★☆ (Socket) ★★☆ (Docker) ★★☆ (Linux, Shell) ★★☆ (CET6) d d d d d d 研究经历 边缘 NDN 网络中基于内容流行度的内网缓存策略 2019.10 - 2020.06 利用 ndnSIM 网络模拟器, 搭建 (Cloud-Edge-User) 树状网络, 实现基于数据名称的网络请求模型; 研究基于内容流行度感知的内网缓存策略, 并经实验模拟, 证明其效果优于大部分其他已存在的策略; 阿里巴巴混部集群跟踪数据集的研究 2018.10 - 2019.08 利用阿里巴巴2018年发布的集群跟踪数据集 (cluster-trace-v2018)，对阿里云混部集群进行了分析; 研究包括集群混部原理, DAG离线任务调度, 容器在线任务调度, 资源使用率和任务失效分析等; 面向边缘计算中分布式协同学习的低功耗容器放置方法 2018.07 - 2018.09 利用低功耗的容器放置方法, 实现分布式边缘服务器集群上边缘计算的功能; 研究包括基于容器历史资源使用情况的聚类分析, 边缘服务器功耗特征测试和标定, 基于启发式算法的容器最优化放置; 科研成果 论文 : Popularity-aware In-network Caching for Edge NDN Networks (已投稿 IEEE Iot Jounal : SCI 1区) 论文 : 阿里生产云中关于工作负载失效的分析 (待投稿) 论文 : 边缘计算中的函数服务化：挑战与解决 (待投稿) 专利 : 一种优化边缘计算节点部署和管理的命名数据网络方法 (已公布) 专利 : 面向边缘计算中分布式协同学习的低功耗容器放置方法 (已申请) 获奖情况 2019 : 校数学建模竞赛一等奖, 全国数学建模竞赛三等奖 2018 - 2019 : 一等奖学金2次 2014 - 2018 : 一等奖学金1次, 二等奖学金3次, 校优秀毕业生","link":"/about/Resume.html"}],"posts":[{"title":"动态规划","text":"动态规划 共 30 题 斐波那契数列70. 爬楼梯 [E]假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 123456输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 1234567输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 分析 定义第 i 阶的爬法为 step[i] 第 n 阶台阶的爬法, 是第 n-1 阶和第 n-2 阶爬法之和, 有状态转移方程,$$step[i]=step[i-1]+step[i-2]$$ 起始条件 : step[0] = 1 step[1] = 2 满足斐波那契数列 123456789101112131415161718192021class Solution {public: int climbStairs(int n) { if (n &lt;= 2) return n; int* step = new int[n]; step[0] = 1; step[1] = 2; for (int i = 2; i &lt; n; i++) { step[i] = step[i - 1] + step[i - 2]; } return step[n - 1]; }};int main() { int n = 5; Solution a; cout &lt;&lt; a.climbStairs(n) &lt;&lt; endl;} 198. 打家劫舍 [E]你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 分析 定义 nums[i] 为到第 i 家为止, 能获取的最多钱 对于第 i 家来说, 如果偷, 则获取的钱为 nums[i-2]+nums[i]; 诺不偷, 则获取的钱为 nums[i-1] $$nums[i] = max(nums[i-2]+nums[i],nums[i-1])$$ 起始条件 : nums[0] = nums[0] nums[1] = max(nums[0],nums[1]) 123456789101112131415161718192021class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt;= 0) return 0; if (nums.size() == 1) return nums[0]; if (nums.size() == 2) return nums[0] &gt; nums[1] ? nums[0] : nums[1]; nums[1] = nums[0] &gt; nums[1] ? nums[0] : nums[1]; for (int i = 2; i &lt; nums.size(); i++) { nums[i] = nums[i - 1] &gt; (nums[i - 2] + nums[i]) ? nums[i - 1] : (nums[i - 2] + nums[i]); } return nums[nums.size() - 1]; }};int main() { vector&lt;int&gt; n = {2,1,1,2}; Solution a; cout &lt;&lt; a.rob(n) &lt;&lt; endl;} 213. 打家劫舍 II [M]你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 123输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2: 1234输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 分析 与 打家劫舍I 区别在于首尾两个位置不能同时取到; 拆分为两次 打家劫舍I 的判断, 分别为 [0,n-1) 和 [1,n) , 两个区间, 最后取较大的结果 1234567891011121314151617181920212223242526class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { int n = nums.size(); if (n == 0) return 0; if (n == 1) return nums[0]; return subrob(nums, 0, n - 1) &gt; subrob(nums, 1, n) ? subrob(nums, 0, n - 1) : subrob(nums, 1, n); } int subrob(vector&lt;int&gt;&amp; nums,int start, int end) { int pre2 = 0, pre1 = 0; for (int i = start; i &lt; end; i++) { int cur = pre2 + nums[i] &gt; pre1 ? pre2 + nums[i] : pre1; pre2 = pre1; pre1 = cur; } return pre1; }};int main() { vector&lt;int&gt; n = {2,1,1,2}; Solution a; cout &lt;&lt; a.rob(n) &lt;&lt; endl;} 信件错排NowCoder每天要给很多人发邮件。有一天他发现发错了邮件，把发给A的邮件发给了B，把发给B的邮件发给了A。于是他就思考，要给n个人发邮件，在每个人仅收到1封邮件的情况下，有多少种情况是所有人都收到了错误的邮件？即没有人收到属于自己的邮件。 分析 动态数组 a[i] 代表有 i 份信件时的错排次数 状态转移方程:$$a[i]=(i-1)a[i-1]+(i-1)a[i-2]$$ 第 i 个信必须和前面信件交换, 交换的位置有 i-1 个; 被交换的元素本身是错放的, 这种情况有 a[i-1] 种; 被交换的元素本身放在正确的位置上(交换后才完全错放), 这种情况只有 i-2 个元素被错放, 即 a[i-2]; 123456789101112131415161718192021class Solution {public: int errorNum(int n) { if (n &lt;= 1)return 0; if (n == 2)return 1; int* a = new int[n + 1]; a[1] = 0; a[2] = 1; for (int i = 3; i &lt;= n; i++) { a[i] = (i - 1) * (a[i - 1] + a[i - 2]); } return a[n]; }};int main() { int n = 5; Solution a; cout &lt;&lt; a.errorNum(n) &lt;&lt; endl;} 母牛生产假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。 分析 第 i 年成熟的牛的数量为：dp[i] 状态转移方程: $$dp[i]=dp[i-1]+dp[i-3]$$ 前3年的牛到今年都可以生产一头母牛 1234567891011121314151617181920class Solution {public: int cow(int n) { if (n &lt; 0)return 0; n = n + 2; int* dp = new int[n + 1]; dp[0] = dp[1] = dp[2] = 1; for (int i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 3]; } return dp[n]; }};int main() { int n = 3; Solution a; cout &lt;&lt; a.cow(n) &lt;&lt; endl;} 矩阵路径64. 最小路径和 [M]给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 1234567## 输入:[ [1,3,1], [1,5,1], [4,2,1]]## 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 分析 res[i][j] 代表到达该点的最小总值; res[0][0]=grid[0][0], 首行和首列只有一个方向移动的条件 $$res[i][0]=res[i-1][0]+grid[i][0]\\res[0][i] = res[0][i-1] + grid[0][i]$$ 其余的满足状态转移方程 $$res[i][j] = min(res[i - 1][j], res[i][j - 1]) + grid[i][j]$$ 123456789101112131415161718192021222324252627282930class Solution {public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if (grid.size() == 0) return 0; int n = grid.size(); int m = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; res = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m)); res[0][0] = grid[0][0]; for (int i = 1; i &lt; m; i++) { res[0][i] = res[0][i - 1] + grid[0][i]; } for (int i = 1; i &lt; n; i++) { res[i][0] = res[i-1][0] + grid[i][0]; } for (int i = 1; i &lt; n; i++) { for (int j = 1; j &lt; m; j++) { res[i][j] = res[i - 1][j] &lt; res[i][j - 1] ? res[i - 1][j] + grid[i][j] : res[i][j - 1] + grid[i][j]; } } return res[n-1][m-1]; }};int main() { vector&lt;vector&lt;int&gt;&gt; grid = { {1,3,1},{1,5,1},{4,2,1} }; Solution a; cout &lt;&lt; a.minPathSum(grid) &lt;&lt; endl;} 62. 不同路径 [M]一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 示例 12345678910111213# 示例 1:输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 # 示例 2:输入: m = 7, n = 3输出: 28 分析 res[i][j] 代表到达该点的总路径数; res[0][0] = 1, 首行和首列只有一个方向移动的条件 $$res[0][0] = 1\\res[i][0]=1\\res[0][i] = 1$$ 其余的满足状态转移方程 $$res[i][j] = res[i - 1][j] + res[i][j - 1]$$ 12345678910111213141516171819202122232425262728class Solution {public: int uniquePaths(int m, int n) { if (m &lt;= 0 || n &lt;= 0) return 0; vector&lt;vector&lt;int&gt;&gt; res = vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n)); res[0][0] = 1; for (int i = 1; i &lt; n; i++) { res[0][i] = 1; } for (int i = 1; i &lt; m; i++) { res[i][0] = 1; } for (int i = 1; i &lt; m; i++) { for (int j = 1; j &lt; n; j++) { res[i][j] = res[i - 1][j] + res[i][j - 1]; } } return res[m - 1][n - 1]; }};int main() { int m = 3; int n = 7; Solution a; cout &lt;&lt; a.uniquePaths(m,n) &lt;&lt; endl;} 数组区间303. 区域和检索 - 数组不可变 [E]给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。 示例 12345# 给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3 分析 res[i] 代表从 0~i 个值的累加结果 sumRange(i, j) = res[j] - res[i-1] NOTE1: i=0 时, 直接返回 res[j] NOTE2: nums 为空时, res[0] = 0 1234567891011121314151617181920212223242526class NumArray {public: vector&lt;int&gt; res; NumArray(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) { res.push_back(0); } else { res.resize(nums.size()); res[0] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) { res[i] = nums[i] + res[i - 1]; } } } int sumRange(int i, int j) { return i == 0 ? res[j] : res[j] - res[i - 1]; }};int main() { vector&lt;int&gt; nums = { }; NumArray a(nums); cout &lt;&lt; a.sumRange(0,0) &lt;&lt; endl;} 413. 等差数列划分 [M]如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。 123456# 例如，以下数列为等差数列:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9# 以下数列不是等差数列。1, 1, 2, 5, 7 数组 A 包含 N 个数，且索引从0开始。 数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。 如果满足以下条件，则称子数组(P, Q)为等差数组： 元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。 函数要返回数组 A 中所有为等差数组的子数组个数。 123# 示例:A = [1, 2, 3, 4]返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。 分析 1234567891011121314151617181920212223242526class Solution {public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) { if (A.size() &lt; 3)return 0; int n = A.size(); vector&lt;int&gt; dp(n, 0); dp[0] = 0; dp[1] = 0; for (int i = 2; i &lt; n; i++) { if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) { dp[i] = dp[i - 1] + 1; } } int sum = 0; for (int i = 0; i &lt; n; i++) { sum += dp[i]; } return sum; }}; int main() { vector&lt;int&gt; A = { 1,2,3,4 }; Solution a; cout &lt;&lt; a.numberOfArithmeticSlices(A) &lt;&lt; endl;} 分割整数343. 整数拆分 [M]给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 123456789# 示例 1:输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。# 示例 2:输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 1234567891011121314151617181920class Solution {public: int integerBreak(int n) { if (n == 1) return 0; vector&lt;int&gt; dp(n + 1, 0); dp[1] = 1; for (int i = 2; i &lt;= n; i++) { for (int j = 1; j &lt; i; j++) { dp[i] = max(dp[i], j * max(i - j, dp[i - j])); } } return dp[n]; }}; int main() { int n = 10; Solution a; cout &lt;&lt; a.integerBreak(n) &lt;&lt; endl;} 279. 完全平方数 [M]给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 12345678910# 示例 1:输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4.# 示例 2:输入: n = 13输出: 2解释: 13 = 4 + 9. 1234567891011121314151617181920class Solution {public: int numSquares(int n) { if (n &lt; 0) return 0; vector&lt;int&gt; dp(n + 1, n); dp[0] = 0; for (int i = 1; i &lt;= n; i++) { for (int k = 0; k * k &lt;= i; k++) { dp[i] = min(dp[i], dp[i - k * k] + 1); } } return dp[n]; }}; int main() { int n = 13; Solution a; cout &lt;&lt; a.numSquares(n) &lt;&lt; endl;} 91. 解码方法 [M]一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 123456789# 示例 1:输入: \"12\"输出: 2解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。# 示例 2:输入: \"226\"输出: 3解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。 1234567891011121314151617181920212223242526class Solution {public: int numDecodings(string s) { if (s.size() == 0) return 0; if (s[0] == '0') return 0; int n = s.size(); vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; // dp[1] = 1; for (int i = 2; i &lt;= n; i++) { if (s[i-1] != '0') { dp[i] += dp[i - 1]; } if ((s[i - 2] == '1') || (s[i - 2] == '2' &amp;&amp; (s[i - 1] - '0') &lt; 7)) { dp[i] += dp[i - 2]; } } return dp[n]; }}; int main() { string s = \"226\"; Solution a; cout &lt;&lt; a.numDecodings(s) &lt;&lt; endl;} 最长递增子序列300. 最长上升子序列 [M]给定一个无序的整数数组，找到其中最长上升子序列的长度。 12345# 示例:输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n^2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 123456789101112131415161718192021222324// 动态规划 - O(n^2)class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; vector&lt;int&gt; dp(nums.size(), 1); int Max = dp[0]; for (int i = 1; i &lt; nums.size(); i++) { for (int j = 0; j &lt; i; j++) { if (nums[j] &lt; nums[i]) { dp[i] = max(dp[j] + 1, dp[i]); } } Max = max(Max, dp[i]); } return Max; }};int main() { vector&lt;int&gt; nums = { 10,9,2,5,3,7,101,18 }; Solution a; cout &lt;&lt; a.lengthOfLIS(nums) &lt;&lt; endl;} 1234567891011121314151617181920212223242526272829303132333435363738// 贪心 + 二分查找 O(nlogn)class Solution {public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { if (nums.size() == 0) return 0; vector&lt;int&gt; order; order.push_back(nums[0]); for (int i = 1; i &lt; nums.size(); i++) { int l = 0; int h = order.size(); while (l &lt; h) { int mid = l + (h - l) / 2; if (order[mid] == nums[i]) { h = mid; } if (order[mid] &lt; nums[i]) { l = mid + 1; } if (order[mid] &gt; nums[i]) { h = mid; } } if (l == order.size()) { order.push_back(nums[i]); } else { order[l] = nums[i]; } } return order.size(); }};int main() { vector&lt;int&gt; nums = { 10,9,2,5,3,7,101,18 }; Solution a; cout &lt;&lt; a.lengthOfLIS(nums) &lt;&lt; endl;} 646. 最长数对链 [M]给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。 现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。 给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。 12345## 示例 :输入: [[1,2], [2,3], [3,4]]输出: 2解释: 最长的数对链是 [1,2] -&gt; [3,4] 注意： 给出数对的个数在 [1, 1000] 范围内。 1234567891011121314151617181920212223242526272829// 动态规划inline bool cmd(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) { return a[1] &lt; b[1];}class Solution {public: int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) { if (pairs.size() == 0) return 0; sort(pairs.begin(),pairs.end(),cmd); vector&lt;int&gt; dp(pairs.size(), 1); int Max = 1; for (int i = 1; i &lt; pairs.size(); i++) { for (int j = 0; j &lt; i; j++) { if (pairs[j][1] &lt; pairs[i][0]) { dp[i] = max(dp[i], dp[j] + 1); } } Max = max(Max, dp[i]); } return Max; }};int main() { vector&lt;vector&lt;int&gt;&gt; pairs = { {1,2 },{2,3},{3,4} }; Solution a; cout &lt;&lt; a.findLongestChain(pairs) &lt;&lt; endl;} 1234567891011121314151617181920212223// 贪心inline bool cmd(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b) { return a[1] &lt; b[1];}class Solution {public: int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) { if (pairs.size() == 0) return 0; sort(pairs.begin(),pairs.end(),cmd); int count = pairs.size(); int per = pairs[0][1]; for (int i = 1; i &lt; pairs.size(); i++) { if (per &lt; pairs[i][0]) { per = pairs[i][1]; } else { count--; } } return count; }}; 376. 摆动序列 [M]如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 12345678910111213# 示例 1:输入: [1,7,4,9,2,5]输出: 6 解释: 整个序列均为摆动序列。# 示例 2:输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。# 示例 3:输入: [1,2,3,4,5,6,7,8,9]输出: 2 进阶:你能否用 O(n) 时间复杂度完成此题? 1234567891011121314151617class Solution {public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt; 2) return nums.size(); int up = 1; int down = 1; for (int i = 1; i &lt; nums.size(); i++) { if (nums[i] - nums[i - 1] &gt; 0) { up = down + 1; } if (nums[i] - nums[i - 1] &lt; 0) { down = up + 1; } } return max(up, down); }}; 最长公共子序列对于两个子序列 S1 和 S2，找出它们最长的公共子序列。 定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况： 当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 dp [i] [j] = dp [i-1] [j-1] + 1。 当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp [i] [j] = max{ dp [i-1] [j], dp[i] [j-1] }。 综上，最长公共子序列的状态转移方程为：$$dp[i][j] = dp[i-1][j-1] + 1, S1i == S2j\\dp[i][j] = max{ dp[i-1][j], dp[i][j-1], S1i != S2j }$$ 1143. 最长公共子序列 [M]给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 1234567891011121314# 示例 1:输入：text1 = \"abcde\", text2 = \"ace\" 输出：3 解释：最长公共子序列是 \"ace\"，它的长度为 3。# 示例 2:输入：text1 = \"abc\", text2 = \"abc\"输出：3解释：最长公共子序列是 \"abc\"，它的长度为 3。# 示例 3:输入：text1 = \"abc\", text2 = \"def\"输出：0解释：两个字符串没有公共子序列，返回 0。 12345678910111213141516171819202122232425class Solution {public: int longestCommonSubsequence(string text1, string text2) { if (text1.size() == 0 || text2.size() == 0) return 0; int n1 = text1.size(); int n2 = text2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n1 + 1, vector&lt;int&gt;(n2 + 1, 0)); for (int i = 1; i &lt;= n1; i++) { for (int j = 1; j &lt;= n2; j++) { if (text1[i - 1] == text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } return dp[n1][n2]; }};int main() { string text1 = \"abcde\"; string text2 = \"ace\"; Solution a; cout &lt;&lt; a.longestCommonSubsequence(text1,text2) &lt;&lt; endl;} 0-1 背包有容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。 定义一个二维数组 dp 存储最大价值，其中 dp [i] [j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论： 第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp [i] [j] = dp [i-1] [j]。 第 i 件物品添加到背包中，dp [i] [j] = dp [i-1] [j-w] + v。 第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：$$dp[i][j]=max(dp[i-1][j],dp[i-1][j-w] + v)$$空间优化 在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1] [j] 也可以表示 dp[i] [j]。此时，$$dp[j]=max(dp[j],dp[j-w]+v)$$因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。 无法使用贪心算法的解释 0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22. id w v v/w 0 1 6 6 1 2 10 5 2 3 12 4 变种 完全背包：物品数量为无限个 多重背包：物品数量有限制 多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制 其它：物品之间相互约束或者依赖 416. 分割等和子集 [M]给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 注意: 每个数组中的元素不会超过 100数组的大小不会超过 200 123456789# 示例 1:输入: [1, 5, 11, 5]输出: true解释: 数组可以分割成 [1, 5, 5] 和 [11].# 示例 2:输入: [1, 2, 3, 5]输出: false解释: 数组不能分割成两个元素和相等的子集. 12345678910111213141516171819202122232425262728class Solution {public: bool canPartition(vector&lt;int&gt;&amp; nums) { if (nums.size() &lt; 1) return false; int n = nums.size(); int m = 0; for (int i = 0; i &lt; n; i++) { m += nums[i]; } if (m % 2 != 0) return false; m = m / 2; vector&lt;int&gt; dp(m + 1,0); dp[0] = 1; for (int i = 0; i &lt; n; i++) { for (int j = m; j &gt;= nums[i]; j--) { dp[j] = dp[j] || dp[j - nums[i]]; } } return dp[m]; }};int main() { vector&lt;int&gt; nums = { 1,5,11,5 }; Solution a; cout &lt;&lt; a.canPartition(nums) &lt;&lt; endl;} 494. 目标和 [M]给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 123456789101112# 示例 1:输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int S) { // +: sum_+ = a // _: sum_- = b // a - b = S; a + b = sum_all; a = (S + sum_all)/2 if (nums.size() == 0) return 0; int sum_all = sum(nums); if (sum_all &lt; S || (S + sum_all) % 2 == 1) return 0; int target = (S + sum_all) / 2; vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; for (int i = 0; i &lt; nums.size(); i++) { for (int j = target; j &gt;= nums[i]; j--) { dp[j] = dp[j] + dp[j - nums[i]]; } } return dp[target]; } int sum(vector&lt;int&gt;&amp; nums) { int res = 0; for (int i = 0; i &lt; nums.size(); i++) { res += nums[i]; } return res; }};int main() { vector&lt;int&gt; nums = { 1,2,7,9,981 }; int S = 1000000000; Solution a; cout &lt;&lt; a.findTargetSumWays(nums,S) &lt;&lt; endl;} 474. 一和零 [M]在计算机界中，我们总是追求用有限的资源获取最大的收益。 现在，假设你分别支配着 m 个 0 和 n 个 1。另外，还有一个仅包含 0 和 1 字符串的数组。 你的任务是使用给定的 m 个 0 和 n 个 1 ，找到能拼出存在于数组中的字符串的最大数量。每个 0 和 1 至多被使用一次。 注意: 给定 0 和 1 的数量都不会超过 100。给定字符串数组的长度不会超过 600。 123456789# 示例 1:输入: Array = {\"10\", \"0001\", \"111001\", \"1\", \"0\"}, m = 5, n = 3输出: 4解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 \"10\",\"0001\",\"1\",\"0\" 。# 示例 2:输入: Array = {\"10\", \"0\", \"1\"}, m = 1, n = 1输出: 2解释: 你可以拼出 \"10\"，但之后就没有剩余数字了。更好的选择是拼出 \"0\" 和 \"1\" 。 1234567891011121314151617181920212223242526272829303132333435class Solution {public: int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) { if (strs.size() == 0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = 0; i &lt; strs.size(); i++) { pair&lt;int, int&gt; num = count(strs[i]); for (int j = m; j &gt;= num.first; j--) { for (int k = n; k &gt;= num.second; k--) { dp[j][k] = max(dp[j][k], dp[j - num.first][k - num.second] + 1); } } } return dp[m][n]; } pair&lt;int, int&gt; count(string str) { pair&lt;int, int&gt; res = { 0,0 }; for (char c : str) { if (c == '0') res.first += 1; else res.second += 1; } return res; }};int main() { vector&lt;string&gt; strs = { \"10\",\"0001\",\"111001\",\"1\",\"0\" }; int m = 5; int n = 3; Solution a; cout &lt;&lt; a.findMaxForm(strs,m,n) &lt;&lt; endl;} 322. 零钱兑换 [M]给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 12345678# 示例 1:输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1# 示例 2:输入: coins = [2], amount = 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 12345678910111213141516171819202122class Solution {public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { if (coins.size() == 0) return -1; vector&lt;int&gt; dp(amount + 1, amount + 1); dp[0] = 0; for (int i = 0; i &lt; coins.size(); i++) { int c = coins[i]; for (int j = c; j &lt;= amount; j++) { dp[j] = min(dp[j - c] + 1, dp[j]); } } return dp[amount] == amount + 1 ? -1 : dp[amount]; }};int main() { vector&lt;int&gt; coins = { 1,2,5 }; int amount = 11; Solution a; cout &lt;&lt; a.coinChange(coins,amount) &lt;&lt; endl;} 518. 零钱兑换 II [M]给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 1234567891011121314151617# 示例 1:输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1# 示例 2:输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。# 示例 3:输入: amount = 10, coins = [10] 输出: 1 1234567891011121314151617181920212223class Solution {public: int change(int amount, vector&lt;int&gt;&amp; coins) { if (amount == 0) return 1; if (coins.size() == 0) return 0; vector&lt;int&gt; dp(amount + 1, 0); dp[0] = 1; for (int i = 0; i &lt; coins.size(); i++) { int c = coins[i]; for (int j = c; j &lt;= amount; j++) { dp[j] = dp[j - c] + dp[j]; } } return dp[amount]; }};int main() { vector&lt;int&gt; coins = { 1,2,5 }; int amount = 5; Solution a; cout &lt;&lt; a.change(amount,coins) &lt;&lt; endl;} 139. 单词拆分 [M]给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。 1234567891011121314# 示例 1：输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]输出: true解释: 返回 true 因为 \"leetcode\" 可以被拆分成 \"leet code\"。# 示例 2：输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]输出: true解释: 返回 true 因为 \"applepenapple\" 可以被拆分成 \"apple pen apple\"。 注意你可以重复使用字典中的单词。# 示例 3：输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]输出: false 1234567891011121314151617181920212223242526272829class Solution {public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { if (s.size() == 0) return true; if (wordDict.size() == 0) return false; int n = s.size(); int m = wordDict.size(); vector&lt;int&gt; dp(n + 1, 0); dp[0] = 1; for (int j = 1; j &lt;= n; j++) { for (int i = 0; i &lt; m; i++) { int len = wordDict[i].size(); if (j &gt;= len) { if (s.substr(j - len, len) == wordDict[i]) { dp[j] = dp[j] || dp[j - len]; } } } } return dp[n]; }};int main() { vector&lt;string&gt; wordDict = { \"apple\", \"pen\" }; string s = \"applepenapple\"; Solution a; cout &lt;&lt; a.wordBreak(s,wordDict) &lt;&lt; endl;} 377. 组合总和 Ⅳ [M]给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 12345678910111213示例:nums = [1, 2, 3]target = 4所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。 123456789101112131415161718192021222324class Solution {public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { if (target == 0) return 1; if (nums.size() == 0) return 0; vector&lt;int&gt; dp(target + 1, 0); dp[0] = 1; int n = nums.size(); for (int j = 1; j &lt;= target; j++) { for (int i = 0; i &lt; n; i++) { if(j &gt;= nums[i]) dp[j] = dp[j] + dp[j - nums[i]]; } } return dp[target]; }};int main() { vector&lt;int&gt; nums = { 3, 33, 333 }; int target = 10000; Solution a; cout &lt;&lt; a.combinationSum4(nums, target) &lt;&lt; endl;} 股票交易 309. 最佳买卖股票时机含冷冻期 [M]给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 1234# 示例:输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] $$dp[i][0]=max(dp[i-1][0],dp[i-1][1]+price[i])\\dp[i][1]=max(dp[i-1][1],dp[i-2][0]-price[i])$$ 123456789101112131415161718192021222324class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; int n = prices.size(); int dp_0 = 0; //int dp_1 = INT_MIN; int dp_1 = -prices[0]; int dp_0_pre = 0; for (int i = 1; i &lt;= n; i++) { int temp = dp_0; dp_0 = max(dp_0, dp_1 + prices[i - 1]); dp_1 = max(dp_1, dp_0_pre - prices[i - 1]); dp_0_pre = temp; } return dp_0; }};int main() { vector&lt;int&gt; prices = { 1,2,3,0,2 }; Solution a; cout &lt;&lt; a.maxProfit(prices) &lt;&lt; endl;} 714. 买卖股票的最佳时机含手续费 [M]给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 123456789# 示例 1:输入: prices = [1, 3, 2, 8, 4, 9], fee = 2输出: 8解释: 能够达到的最大利润: 在此处买入 prices[0] = 1在此处卖出 prices[3] = 8在此处买入 prices[4] = 4在此处卖出 prices[5] = 9总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. $$dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]-2)\\dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i])$$ 12345678910111213141516171819202122class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) { if (prices.size() == 0) return 0; int n = prices.size(); int dp_0 = 0; int dp_1 = - prices[0]; for (int i = 1; i &lt;= n; i++) { int temp = dp_0; dp_0 = max(dp_0, dp_1 + prices[i - 1] - fee); dp_1 = max(dp_1, temp - prices[i - 1]); } return dp_0; }};int main() { vector&lt;int&gt; prices = { 1, 3, 2, 8, 4, 9 }; int fee = 2; Solution a; cout &lt;&lt; a.maxProfit(prices,fee) &lt;&lt; endl;} 123. 买卖股票的最佳时机 III [H]给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 1234567891011121314151617# 示例 1:输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。# 示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。# 示例 3:输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 $$dp[i][k][0]=max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])\\dp[i][k][1]=max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])$$ 12345678910111213141516171819202122class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; int n = prices.size(); vector&lt;int&gt; dp_0(2 + 1, 0); vector&lt;int&gt; dp_1(2 + 1, -prices[0]); for (int i = 1; i &lt;= n; i++) { for (int k = 2; k &gt;= 1; k--) { dp_0[k] = max(dp_0[k], dp_1[k] + prices[i - 1]); dp_1[k] = max(dp_1[k], dp_0[k - 1] - prices[i - 1]); } } return dp_0[2]; }};int main() { vector&lt;int&gt; prices = { 9,8,7,6,8,5,3,2,1 }; Solution a; cout &lt;&lt; a.maxProfit(prices) &lt;&lt; endl;} 188. 买卖股票的最佳时机 IV [H]给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 12345678910# 示例 1:输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。# 示例 2:输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 1234567891011121314151617181920212223242526272829303132class Solution {public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) { if (prices.size() == 0) return 0; int n = prices.size(); if(k &gt;= n/2) { int res = 0; for(int i = 1; i &lt; n; i++){ if(prices[i] - prices[i - 1] &gt; 0) res += prices[i] - prices[i - 1]; } return res; } vector&lt;int&gt; dp_0(k + 1, 0); vector&lt;int&gt; dp_1(k + 1, -prices[0]); for (int i = 1; i &lt;= n; i++) { for (int j = k; j &gt;= 1; j--) { dp_0[j] = max(dp_0[j], dp_1[j] + prices[i - 1]); dp_1[j] = max(dp_1[j], dp_0[j - 1] - prices[i - 1]); } } return dp_0[k]; }};int main() { vector&lt;int&gt; prices = { 3,2,6,5,0,3 }; int k = 2; Solution a; cout &lt;&lt; a.maxProfit(k, prices) &lt;&lt; endl;} 字符串编辑583. 两个字符串的删除操作 [M]给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。 1234# 示例：输入: \"sea\", \"eat\"输出: 2解释: 第一步将\"sea\"变为\"ea\"，第二步将\"eat\"变为\"ea\" 123456789101112131415161718192021222324252627class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(); int m = word2.size(); if (word1.size() == 0 || word2.size() == 0) return n + m; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (word1[i - 1] == word2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max( dp[i - 1][j],dp[i][j - 1] ); } } } return n + m - 2 * dp[n][m]; }};int main() { string word1 = \"sea\"; string word2 = \"eat\"; Solution a; cout &lt;&lt; a.minDistance(word1, word2) &lt;&lt; endl;} 72. 编辑距离 [H]给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符 1234567891011121314151617# 示例 1：输入：word1 = \"horse\", word2 = \"ros\"输出：3解释：horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e')# 示例 2：输入：word1 = \"intention\", word2 = \"execution\"输出：5解释：intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 123456789101112131415161718192021222324252627282930313233class Solution {public: int minDistance(string word1, string word2) { int n = word1.size(); int m = word2.size(); if (n == 0 || m == 0) return m + n; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0)); for (int i = 1; i &lt;= n; i++) { dp[i][0] = i; } for (int i = 1; i &lt;= m; i++) { dp[0][i] = i; } for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { if (word1[i - 1] == word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]; else { // min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j-1]) + 1 dp[i][j] = 1 + (dp[i - 1][j - 1] &lt; dp[i - 1][j] ? min(dp[i - 1][j - 1], dp[i][j - 1]) : min(dp[i - 1][j], dp[i][j - 1])); } } } return dp[n][m]; }};int main() { string word1 = \"horse\"; string word2 = \"ros\"; Solution a; cout &lt;&lt; a.minDistance(word1, word2) &lt;&lt; endl;} 650. 只有两个键的键盘 [M]最初在一个记事本上只有一个字符 ‘A’。你每次可以对这个记事本进行两种操作： Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。Paste (粘贴) : 你可以粘贴你上一次复制的字符。给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 ‘A’。输出能够打印出 n 个 ‘A’ 的最少操作次数。 12345678# 示例 1:输入: 3输出: 3解释:最初, 我们只有一个字符 'A'。第 1 步, 我们使用 Copy All 操作。第 2 步, 我们使用 Paste 操作来获得 'AA'。第 3 步, 我们使用 Paste 操作来获得 'AAA'。 123456789101112131415161718192021222324// 动态规划class Solution {public: int minSteps(int n) { if (n &lt;= 0) return -1; vector&lt;int&gt; dp(n + 1, 0); for (int i = 2; i &lt;= n; i++) { dp[i] = i; for (int k = 2; k &lt;= i / 2; k++) { if (i % k == 0) { dp[i] = min(dp[i],dp[k] + i / k); } } } return dp[n]; }};int main() { int n = 3; Solution a; cout &lt;&lt; a.minSteps(n) &lt;&lt; endl;} 1234567891011121314151617181920212223// 数学 - 递归 - 素数分解class Solution {public: int fun(int n) { for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) return fun(n / i) + i; } return n; } int minSteps(int n) { if (n &lt;= 0) return -1; if (n == 1) return 0; return fun(n); }};int main() { int n = 3; Solution a; cout &lt;&lt; a.minSteps(n) &lt;&lt; endl;}","link":"/2020/06/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"模板","text":"这是博客模板, 用于测试以及方便以后的写作. 面试问题 - 解答模板(问题名称)问题简介 12345# 1:...# 2:...","link":"/2020/06/22/%E6%A8%A1%E6%9D%BF/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"}],"categories":[{"name":"算法刷题","slug":"算法刷题","link":"/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"},{"name":"Leetcode","slug":"算法刷题/Leetcode","link":"/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/"},{"name":"动态规划","slug":"算法刷题/Leetcode/动态规划","link":"/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/Leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}